options {
STATIC = false;
}

PARSER_BEGIN(Parser)
package dev.markmcd.controller.ctl.Parser;

import java.io.IOException;
import java.util.Set;
import java.util.HashSet;
import dev.markmcd.controller.types.modelRelated.ModelCheckInputs;
import dev.markmcd.controller.types.kripke.Kripke;
import dev.markmcd.controller.types.kripke.State;
import dev.markmcd.controller.types.kripke.Transition;

import static dev.markmcd.controller.ctl.CtlUtils.statesWithLabel;
import static dev.markmcd.controller.ctl.CtlUtils.union;
import static dev.markmcd.controller.ctl.CtlUtils.intersection;
import static dev.markmcd.controller.ctl.CtlUtils.subtract;
import static dev.markmcd.utils.Utils.contains;
import static dev.markmcd.utils.Utils.areEqual;

/* clt parser rules approach from https://github.com/pedrogongora/antelope/blob/master/AntelopeCore/src/antelope/ctl/parser/CTLParser.jj, accessed 9/20 */
public class Parser {
    static Kripke kripke;
    static Set S;
    String formula;

    public Parser(ModelCheckInputs modelCheckInputs) {
	  this(modelCheckInputs.getFormulaStream(), null); // dunno what this call does exactly, but it's needed to avoid JavaCC throwing a null error. Compare to the autogenerated constructor in CtlValidator.java line 168
	  kripke = modelCheckInputs.getKripke();
	  this.formula = modelCheckInputs.getFormula();
	  S = kripke.getStates();
    }

    /* these algos are from p. 227 of pdf Logic In CS textbook */

    public static Set EX(Set states) throws IOException {
        return preE(states);
    }

    public static Set EF(Set phi) throws IOException {
        Set tautology = S;
        return EU(tautology,phi);
    }

    // TODO this is totally untested so far
    public static Set EG(Set phi) throws IOException  {
        return not(AF(not(phi)));
    }

    // TODO this is totally untested so far
    public static Set AX(Set states) throws IOException {
        Set notStates = not(states);
        Set EXNotStates = EX(notStates);
        Set notEXNotStates = not(EXNotStates);
        return notEXNotStates;
    }

    public static Set AF(Set states) throws IOException {
        Set X = S;
        Set Y = states;
        while (!areEqual(X,Y)) {
            X = Y;
            Y = union(Y,preA(Y));
        }
        return Y;
    }

    // TODO this is totally untested so far
    public static Set AG(Set states) throws IOException {
        return not(EF(not(states)));
    }

    public static Set EU(Set phi, Set psi) throws IOException {
        Set W = phi;
        Set X = S;
        Set Y = psi;
        while (!areEqual(X,Y)) {
            X = Y;
            Y = union(Y,intersection(W,preE(Y)));
        }
        return Y;
    }

    /* TODO: still needs heavy testing!! */
    public static Set AU(Set phi, Set psi) throws IOException {
        Set EGNotPsi = EG(not(psi));
        Set notPhiAndNotPsi = and(not(phi),not(psi));
        Set ENotPsiUNotPhiAndNotPsi = EU(not(psi),notPhiAndNotPsi);
        Set ENotPsiUNotPhiAndNotPsiOrEGNotPsi = or(ENotPsiUNotPhiAndNotPsi,EGNotPsi);
        Set notENotPsiUNotPhiAndNotPsiOrEGNotPsi = not(ENotPsiUNotPhiAndNotPsiOrEGNotPsi);
        return notENotPsiUNotPhiAndNotPsiOrEGNotPsi;
    }

    public static Set or(Set a, Set b) throws IOException {
        return union(a,b);
    }

    public static Set and(Set a, Set b) throws IOException {
        return intersection(a,b);
    }

    public static Set not(Set a) throws IOException {
        return subtract(S,a);
    }

    /* TODO: function still untested */
    public static Set preE(Set states) throws IOException {
        Set S = kripke.getStates();
        Set preE = new HashSet();
        // Set statesToCheck = subtract(S,states);
        Set statesToCheck = S;
        for (Object stateToCheckObj : statesToCheck) {
            State stateToCheck = (State) stateToCheckObj;
            for (Object transitionToCheckObj : stateToCheck.getTransitions()) {
                Transition transitionToCheck = (Transition) transitionToCheckObj;
                State toState = transitionToCheck.getTo();
                if (contains(states,toState)) {
                    preE.add(stateToCheck);
                }
            }
        }
        return preE;
    }

    /* TODO: function still untested */
    public static Set preA(Set states) throws IOException {
        Set S = kripke.getStates();
        Set preA = new HashSet();
        // Set statesToCheck = subtract(S,states);
        Set statesToCheck = S;
        for (Object stateToCheckObj : statesToCheck) {
            Boolean isPreA = true;
            State stateToCheck = (State) stateToCheckObj;
            if (stateToCheck.getTransitions().size() > 0) {
                for (Object transitionToCheckObj : stateToCheck.getTransitions()) {
                    Transition transitionToCheck = (Transition) transitionToCheckObj;
                    State toState = transitionToCheck.getTo();
                    if (!contains(states,toState)) {
                        isPreA = false;
                    }
                }
            } else {
                isPreA = false;
            }
            if (isPreA) {
                preA.add(stateToCheck);
            }
        }
        return preA;
    }

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
      <NOT: "not">
    | <AND: "and">
    | <OR: "or">
    | <IMPLIES: "->">
    | <AX: "AX">
    | <AF: "AF">
    | <AG: "AG">
    | <EX: "EX">
    | <EF: "EF">
    | <EG: "EG">
    | <A: "A">
    | <E: "E">
    | <U: "U">
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <ATOM: ["a"-"z"](["0"-"9"])*>
}

/** Root production. */
Set Parse() throws ParseException, IOException :
{
    Set f;
}

{
    f = formula(kripke.getStates()) <EOF>
    { return f; }
}

Set formula(Set states) throws ParseException, IOException :
{
    Set e;
    Set b = null;
}
{
        e = expression(states) [ b = binaryOp(e,states) ]
        {
            if (b != null) { return b; }
            else { return e; }
        }

}

Set expression(Set states) throws ParseException, IOException :
{
 Token t;
 Set f;
 Set e;
 Set b;
}
{
        t = <ATOM>
        {
            Set statesWithLabels = statesWithLabel(states, t);
            // System.out.println(statesWithLabels);
            return statesWithLabels;
        }
    |   <NOT> f = formula(states)
        {
            return not(f);
        }
    |   <LPAREN> f = formula(states) <RPAREN>
        { return f; }
    |   f = temporalExpression(states)
        { return f; }
    | <E> <LPAREN> e = expression(states) <U> b = expression(states) <RPAREN>
      { return EU(e,b); }
    | "A" <LPAREN> e = expression(states) <U> b = expression(states) <RPAREN>
      { return AU(e,b); }
}

Set binaryOp(Set subject, Set states) throws ParseException, IOException :
{ Set predicate; }
{
        <AND> predicate = formula(states)
        { return and(subject,predicate); }
    |   <OR> predicate = formula(states)
        { return or(subject,predicate); }
    |   <IMPLIES> predicate = formula(states)
        {
            /* TODO: need to test this implies out a bunch - no idea if it's working right */
            return or(not(subject),predicate);  /* (not subject or predicate) */
        }
}

Set temporalExpression(Set s) throws ParseException, IOException :
{ Set e; }
{
     <AX> e = expression(s)
      { return AX(e); }
    |<AF> e = expression(s)
      { return AF(e); }
    | <AG> e = expression(s)
      { return AG(e); }
    | <EX> e = expression(s)
      { return EX(e); }
    | <EF> e = expression(s)
      { return EF(e); }
    | <EG> e = expression(s)
      { return EG(e); }
}